# 复矩阵的特征值点云

本文将之前的转移矩阵更进一步，不再局限于右随机矩阵，尝试扩展到复矩阵，并且对复矩阵的特征值分布进行可视化。本文通过渲染点云的方式展示特征值分布，由于要绘制的内容较多，且与特征值的科学计算深度耦合，因此本文采用 pyOpenGL 实现点云渲染。这就又绕回到 OpenGL 来了。

[https://github.com/listenzcc/stochastic-matrix.git](https://github.com/listenzcc/stochastic-matrix.git)

---
- [复矩阵的特征值点云](#复矩阵的特征值点云)
  - [随机复矩阵的构造](#随机复矩阵的构造)
  - [特征值点云分布与连续性](#特征值点云分布与连续性)
  - [附录：pyOpenGL 渲染方法](#附录pyopengl-渲染方法)
- [转移矩阵-3](#转移矩阵-3)
  - [Math](#math)
  - [Appendix: Code description (Auto generated by sourcery)](#appendix-code-description-auto-generated-by-sourcery)
  - [Appendix: Code explanation (Auto generated by sourcery)](#appendix-code-explanation-auto-generated-by-sourcery)
    - [How to install PyOpenGL](#how-to-install-pyopengl)


## 随机复矩阵的构造

随机数值的复数矩阵，就是矩阵中每个元素的数值不只是实数，而有可能是复数。

$$
\begin{cases} 
M \in \mathbb{C}^{n\times n} \\
M_{ij} =a + ib, a, b\in (-1, 1)
\end{cases}
$$

同时，我还使用 opensimplex 生成的连续 perlin 噪声，实现随机数值的连续变换。

[OpenSimplex noise](https://en.wikipedia.org/wiki/OpenSimplex_noise)

为了实现比较好看的视觉效果，将特定位置的数值进行连续变化，使用网格搜索策略追踪它们的变化过程中，矩阵特征值的变化

$$
M_{p}, M_{q} \in (\underbrace{-10, -9.99 \dots 9.99 ,10}_k)
$$

其中，$p, q$ 代表矩阵中的两个固定位置，它们的数值变化彼此独立，因此可以通过 $k^2$ 次网格搜索实现随机值的遍历，其中每次搜索都需要进行一次特征值计算。

```python
mat = np.zeros((n, n), dtype=np.complex64)
mat.real = np.random.randn(n, n)
mat.imag = np.random.randn(n, n)

buffer = []

for t1 in np.linspace(tmin, tmax, grids):
    for t2 in np.linspace(tmin, tmax, grids):
        mat.real[1][0] = t1
        mat.real[2][1] = t2
        eig = np.linalg.eig(mat)

        buffer.extend(
            dict(real=e.real, imag=e.imag, t1=t1, t2=t2, order=i)
            for i, e in enumerate(eig[0])
        )

data = pd.DataFrame(buffer)
```

![Untitled](%E5%A4%8D%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E7%82%B9%E4%BA%91%20a32853b956a54be1b611ead83464b2fc/Untitled.png)

[Simone Conradi on Twitter / X](https://twitter.com/S_Conradi/status/1705567039291580630)

## 特征值点云分布与连续性

接下来进行特征值计算和渲染。对某一个随机矩阵的计算会生成 $n \times k^2$ 个特征值，它们的标记是特征值序号和网格搜索值。由于要绘制的内容较多，且与特征值的科学计算深度耦合，因此本文采用 pyOpenGL 实现点云渲染。

[PyOpenGL -- The Python OpenGL Binding](https://pyopengl.sourceforge.net/)

- 按特征值序号着色
    
    由于矩阵的非零特征值数量与它的秩相同，因此可以按特征值序号进行着色。
    

![Figure_3.png](%E5%A4%8D%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E7%82%B9%E4%BA%91%20a32853b956a54be1b611ead83464b2fc/Figure_3.png)

![Figure_4.png](%E5%A4%8D%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E7%82%B9%E4%BA%91%20a32853b956a54be1b611ead83464b2fc/Figure_4.png)

- 按网格搜索值着色
    
    按照矩阵中的 $M_p$ 和 $M_q$ 值进行着色，两个数值分别对应红色和蓝色通道。
    

![Untitled](%E5%A4%8D%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E7%82%B9%E4%BA%91%20a32853b956a54be1b611ead83464b2fc/Untitled%201.png)

![Untitled](%E5%A4%8D%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E7%82%B9%E4%BA%91%20a32853b956a54be1b611ead83464b2fc/Untitled%202.png)

![20231011-163424.gif](%E5%A4%8D%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E7%82%B9%E4%BA%91%20a32853b956a54be1b611ead83464b2fc/20231011-163424.gif)

![Untitled](%E5%A4%8D%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E7%82%B9%E4%BA%91%20a32853b956a54be1b611ead83464b2fc/Untitled%203.png)

如上图所示，OpenGL 能够将大量点集渲染得足够快，计算瓶颈主要集中在大量的特征值计算过程中，约耗时 0.25 秒。

## 附录：pyOpenGL 渲染方法

在 pyOpenGL 中，vbo 绑定和 points 渲染似乎比 webGL 更加简便，核心代码如下

```python
# Code for vbo and points rendering
import OpenGL.arrays.vbo as glvbo
from OpenGL import GL as gl
from OpenGL import GLUT as glut

vbo_pos = glvbo.VBO(attrs['pos'])
vbo_pos.bind()
gl.glEnableClientState(gl.GL_VERTEX_ARRAY)
gl.glVertexPointer(2, gl.GL_FLOAT, 0, vbo_pos)

vbo_rgba = glvbo.VBO(attrs['rgba'])
vbo_rgba.bind()
gl.glEnableClientState(gl.GL_COLOR_ARRAY)
gl.glColorPointer(4, gl.GL_FLOAT, 0, vbo_rgba)

gl.glDrawArrays(gl.GL_POINTS, 0, attrs['n'])
```

本文使用最简单的 mainloop 循环，它似乎不怎么稳定，之后还有待调整。

```python
# Code for OpenGL mainloop
glut.glutInit()

glut.glutInitDisplayMode(glut.GLUT_SINGLE | glut.GLUT_RGBA)

glut.glutInitWindowSize(400, 400)
glut.glutInitWindowPosition(500, 300)

glut.glutCreateWindow("Wnd-1")
glut.glutDisplayFunc(display)

glut.glutMainLoop()
```
# 转移矩阵-3

由于这两天的东西比较水，所以写两个事情。

首先，前文中猜想的那个命题根本没有道理，这类矩阵也没有那么复杂，它就是典型的“右随机矩阵”。这类矩阵具有良好的性质，它最大特征值为实数 1，且对应的特征向量为全 1 向量，另外，其他特征值的模总小于 1，这导致它的连乘总收敛于全 1 向量。这种良好的性质是我之前产生误会的根源。这部分的随机值样例可见开源代码

[Right Stochastic Matrix](https://observablehq.com/@listenzcc/right-stochastic-matrix)

其次是除了说明这种现象之外，本文还尝试使用 vscode 中的 sourcery 插件进行代码分析，它可以自动理解代码、生成高质量的文档和测试用例。本文附录部分的全部内容都是由它自动生成的。我只是调整了一下格式。

[Sourcery | Automatically Improve Code Quality](https://sourcery.ai/)

也因为这个原因，本文的内容以英文为主，因为在 vim 模式中切换输入法实在是很不方便。本文的详细代码可见我的 github 仓库

[https://github.com/listenzcc/stochastic-matrix](https://github.com/listenzcc/stochastic-matrix)

---

## Math

The stochastic matrix is $A \in R^{n \times n}$

$\begin{cases} \sum_{j=1}^{n} A_{ij} &= 1\\ A_{ij} &> 0 \end{cases}$

The definition of the stochastic matrix and its properties reads in

[Stochastic matrix](https://en.wikipedia.org/wiki/Stochastic_matrix)

The stochastic matrix in the code is the right version, since

> A right stochastic matrix is a real square matrix, with each row summing to 1.
> 

Define all ones vector as the following.

$E^{n \times 1} = [\underbrace{1, 1, \dots, 1}_n]^T$

In the very long run, it follows.

$E = A \cdot E = A^N \cdot E = \lim_{N \rightarrow \infty} A^N \cdot E$

As a result, the stochastic matrix has eigenvalues.

$\lVert \lambda_i \lVert \le 1$

And the largest eigenvalue equals to $1$, and the eigenvector of the eigenvalue is $E$.
The other eigenvalues and eigenvectors follow the pattens, as below.

![demo.png](%E8%BD%AC%E7%A7%BB%E7%9F%A9%E9%98%B5-3%2081537600a4fd433cbf8e861b6e3e4335/demo.png)

The values and vectors are complex other than real numbers,
so, the inequality changes into, which is also satisfied.

$x^{*T} x \ge x^{*T} \lambda^2 x = x^{*T} A^T A x$

In which, the $x^*$ refers to the conjugate of the $x$.

$\blacksquare$

It converges as the following.

![converge.png](%E8%BD%AC%E7%A7%BB%E7%9F%A9%E9%98%B5-3%2081537600a4fd433cbf8e861b6e3e4335/converge.png)

![converge-2.png](%E8%BD%AC%E7%A7%BB%E7%9F%A9%E9%98%B5-3%2081537600a4fd433cbf8e861b6e3e4335/converge-2.png)

## Appendix: Code description (Auto generated by sourcery)

- rnd_stochastic_matrix(rows: int = 6, cols: int = 6) -> np.array:
Generates a random stochastic matrix with the given number of rows and columns.
A stochastic matrix is a square matrix with nonnegative real entries where each row sums to 1.
This function generates a random matrix and normalizes it to be stochastic.
- compute_eig(mat: np.array):
Computes the eigenvalues and eigenvectors of a matrix.
This function calculates and returns the eigenvalues and eigenvectors
of the input matrix using numpy's linalg.eig function.
- The [test.py](https://www.notion.so/test.py) script is the test instances for the functions.

```powershell
pytest test.py

# ==== test session starts ==================================
# platform win32 -- Python 3.11.4, pytest-7.4.2, pluggy-1.3.0
# rootdir: C:\\Users\\zcc\\Desktop\\eigen
# plugins: anyio-3.5.0
# collected 14 items
#
# test.py ..............
# ==== 14 passed, xx warnings in 1.48s ======================

```

## Appendix: Code explanation (Auto generated by sourcery)

What?
This Python code generates a random stochastic matrix, computes its eigenvalues and eigenvectors, and visualizes the results.

How?
rnd_stochastic_matrix generates a random matrix and normalizes it. compute_eig calculates the eigendecomposition using NumPy.

The **main** section provides a demo - generating a matrix, computing eigenvectors/values, and visualizing them with Pandas/Seaborn.

Coupling and Cohesion
The two functions are loosely coupled. The overall module has high cohesion related to stochastic matrices.

Single Responsibility Principle
Both functions follow SRP. rnd_stochastic_matrix handles generation, compute_eig handles decomposition. No extraction needed.

Unusual Things
None

Highly Suspicious
No input validation in compute_eig could lead to errors.


### How to install PyOpenGL

- Windows: 
  Install PyOpenGL from the website other than the pip
  [pythonlibs/#pyopengl](https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyopengl "pythonlibs/#pyopengl")

- Linux:
  ```bash
  # Pre request
  apt-get install freeglut3-dev

  # Install from pip
  pip install PyOpenGL PyOpenGL_accelerate

  # Install from clone
  git clone https://github.com/mcfletch/pyopengl
  # Install PyOpenGL
  cd pyopengl
  pip install -e .
  # Install PyOpenGL_accelerate
  cd accelerate
  pip install -e .
  ```